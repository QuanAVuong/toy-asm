: BasicBlock subprogram interface
:
: label BASICBLOCK
:
: on entry
:		$F = <return address>
:		$A = @A
:		$B = @B = @A + 1
:		$C = @C = @B + 1 = @A + 2
:		$D = @D = @C + 1 = @B + 2 = @A + 3
:
: on exit
:		C = ( A + B ) & ( A - B )
:		D = ( A + B ) | ( A - B ) + 17
:		Memory, except for C and D is unchanged
:		(There is no constraint on any register values.)
:
: driver register usage (subprogram can be different)
:		$1 =  @C
:		$A =  @C + 1

BASICBLOCK
        mov     $2,     $0      : j = $2 = 0
LOOP
        cmp     $2,     $B      : j ? n
        buge            @DONE	:
            : j < n
        add     $3, $C, $2      : $3 = @X[j]
        l       $4,     $3     	: $4 =  X[j]

        add     $5, $D, $2      : $5 = @Y[j]
        l       $6,     $5     	: $6 =  Y[j]

        add     $7, $4, $6      : $7 =  X[i] + Y[i]

        add     $8, $E, $2      : $8 = @Z[j]
        l       $9,     $8     	: $9                <--(load)--  Z[j] at address found in $8
        st      $7,     $9     	: X[i] + Y[i] = $7  --(store)--> Z[i] at $9
        l       $A,     $9     	: $A                <--(load)-- $9 = X[i] + Y[i] to be written to console. (l vs mov ?)
        write                   : print Z[j] in command window 

        add     $2, $2, $1 	: j <- j + 1
        b	      @LOOP 	: repeat loop body
DONE
        ret	            	: return to caller [	blc	ALL, $F, $0]